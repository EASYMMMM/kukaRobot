function  [jPosd , eefError , eefdError , eefddError  ] = admittanceController(eefErrorLast,  eefdErrorLast ,  eefddErrorLast ,  timeInt , eefTarget  , eefTargetd , jPos ,k_cartesian, b_cartesian, H_inv,KP)
% 导纳控制器 -- 笛卡尔空间
%  [jPosd , eefError , eefdError , eefddError  ] = admittanceController(eefErrorLast,  eefdErrorLast ,  eefddErrorLast ,  timeInt , eefTarget  , eefTargetd , jPos ,k_cartesian, b_cartesian, H_inv)
% ================== parameters ==============================
% eefErrorLast, eefdErrorLast, eefddErrorLast：上次的位移，速度，加速度偏差
% timeInt：控制时间间隔
% eefTarget,eefTargetd：目标位置，目标速度
% jPos：机器人当前关节姿态  7*1 cell
% k_cartesian, b_cartesian, H_inv：导纳参数 虚拟刚度 虚拟阻尼 虚拟质量
% 
     eefddError = H_inv*(ExEEFForce - b_cartesian * eefdErrorLast - k_cartesian * eefErrorLast); %本周期 加速度偏差
     eefdError = eefdErrorLast + (eefddError + eefddErrorLast)*timeInt/2;
     eefError = eefErrorLast + (eefdError + eefdErrorLast)*timeInt/2;
    
     eefTargetNew = eefTarget + eefError;   %导纳控制器更新后的目标位置和目标速度
     eefTargetdNew = eefTargetd + eefdError;
    
     [eefT, eefJacobian ] = iiwa.gen_DirectKinematics(cell2mat(jPos));
     eefCartNow = eefT(1:3,4);  %当前末端位置
        
     ep = eefTargetNew - eefCartNow;   %当前位置与更新后的目标位置的偏差
     controlSignal = KP*ep + eefTargetdNew ;
    
     JVel = eefJacobian(1:3,:);    
    
     jPosd = pinv(JVel) * controlSignal;
     jPosdLast = jPosd;
%      iiwa.sendJointsVelocities(num2cell(jPosd));  %输出关节速度

%      eefErrorLast = eefError;   %记录本次偏差
%      eefdErrorLast = eefdError;
%      eefddErrorLast = eefddError;
end